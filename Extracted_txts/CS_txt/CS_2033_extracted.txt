 

13.3. Application I/O Interface 471

The hardware to measure elapsed time and to trigger operations is called
a programmable interval timer. It can be set to wait a certain amount of time
and then to generate an interrupt. It can be set to do this operation once, or
to repeat the process, to generate periodic interrupts. The scheduler uses this
mechanism to generate an interrupt that will preempt a process at the end of
its time slice. The disk I/O subsystem uses it to invoke the flushing of dirty
cache buffers to disk periodically, and the network subsystem uses it to cancel
operations that are proceeding too slowly because of network congestion or
failures. The operating system may also provide an interface for user processes
to use timers. The operating system can support more timer requests than the
number of timer hardware channels by simulating virtual clocks. To do so, the
kernel (or the timer device driver) maintains a list of interrupts wanted by its
own routines and by user requests, sorted in earliest-time-first order. It sets the
timer for the earliest time. When the timer interrupts, the kernel signals the
requester, and reloads the timer with the next earliest time.

On many computers, the interrupt rate generated by the ticking of the
hardware clock is between 18 and 60 ticks per second. This resolution is coarse,
since a modern computer can execute hundreds of millions of instructions per
second. The precision of triggers is limited by the coarse resolution of the
timer, together with the overhead of maintaining virtual clocks. And, if the
timer ticks are used to maintain the system time-of-day clock, the system clock
can drift. In most computers, the hardware clock is constructed from a high-
frequency counter. In some computers, the value of this counter can be read
from a device register, in which case the counter can be considered to bea
high-resolution clock. Although this clock does not generate interrupts, it offers
accurate measurements of time intervals.

13.3.4 Blocking and Nonblocking I/O

Another aspect of the system-call interface relates to the choice between block-
ing I/O and nonblocking (or asynchronous) I/O. When an application issues
a blocking system call, the execution of the application is suspended. The
application is moved from the operating system’s run queue to a wait queue.
After the system call completes, the application is moved back to the run queue,
where it is eligible to resume execution, at which time it will receive the values
returned by the system call. The physical actions performed by 1/0 devices
are generally asynchronous—they take a varying or unpredictable amount of
time. Nevertheless, most operating systems use blocking system calls for the
application interface, because blocking application code is easier to understand
than nonblocking application code.

Some user-level processes need nonblocking I/O. One example is a user
interface that receives keyboard and mouse input while processing and dis-
playing data on the screen. Another example is a video application that reads
