Section 10.3.

Logic Programming Systems 307

 

CONTINUATIONS

is an abstract instruction set that is suitable for Prolog and can be either interpreted or translated
into machine language. Other compilers translate Prolog into a high-level language such as Lisp
or C, and then use that language's compiler to translate to machine language. For example, the
definition of the Member predicate can be compiled into the code shown in Figure 10.4.

 

procedure MEMBER(item, list, continuation)

trail — GLOBAL-TRAIL-POINTER()

if UNIFY([item I NEW-VARIABLE()], list) then CALL(continuation)
RESET-TRAIL(frail)

rest — NEW-VARIABLE()

if UniFy(list, [NEW-VARIABLE() I rest]) then MEMBER(item, rest, continuation)

 

 

Figure 104 — Pseudocode representing the result of compiling the Member predicate. The
function NEW-VARIABLE returns a new variable, distinct from all other variables so far used. The
procedure CALL(continuation)continues execution with the specified continuation.

 

 

 

There are several points worth mentioning:

+ Rather than having to search the knowledge base for Member clauses, the clauses are built
into the procedure and the inferences are carried out simply by calling the procedure

+ As described earlier, the current variable bindings are kept on a trail. The first step of the
procedure saves the current state of the trail, so that it can be restored by RESET-TRAIL if
the first clause fails. This will undo any bindings generated by the first call to UNIFY.

+ The trickiest part is the use of continuations to implement choice points. You can think
of a continuation as packaging up a procedure and a list of arguments that together define
what should be done next whenever the current goal succeeds. It would not dojust to retumn
from a procedure like MEMBER when the goal succeeds, because it may succeed in several
ways, and each of them has to be explored. The continuation argument solves this problem
because it can be called each time the goal succeeds. In the MEMBER code, if item unifies
with the first element of the /ist, then the MEMBER predicate has succeeded. We then CALL
the continuation, with the appropriate bindings on the trail, to do whatever should be done
next. For example, if the call to MEMBER were at the top level, the continuation would
print the bindings of the variables.

Before Warren's work on compilation of inference in Prolog, logic programming was too
slow for general use. Compilers by Warren and others allowed Prolog to achieve speeds of up
to 50,000 LIPS (logical inferences per second) on standard 1990-model workstations. More
recently, application of modern compiler technology, including type inference, open-coding, and
interprocedural data-flow analysis has allowed Prolog to reach speeds of several million LIPS,
making it competitive with C on a variety of standard benchmarks (Van Roy, 1990). Of course,
the fact that one can write a planner or natural language parser in a few dozen lines of Prolog
makes it somewhat more desirable than C for prototyping most small-scale AI research projects.
