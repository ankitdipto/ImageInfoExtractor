4.6 Proof of the master theorem 99

 

 

 

fin)
f(n/b) f(n/b) oo f(n/b) af(n/b)
a a a
log, 1
L(n/b?) f(n/b?)f(n/b?) f(n/b?) f(n/b?)f(n/b?)—— f (nb?) f (a/b?) (n/b?) mst. a? f(n/b?)
(1) ©() ©11) ©11) 4) OG) OG) EL) EL) OF) «-. OF) OF) OCD) jm O(ni™4)
Spa
logy #1
Total: @(n!°%*) + @ f(n/b’)

j=0

Figure 4.7 The recursion tree generated by T(n) = aT (n/b) + f(n). The tree is a complete a-ary
tree with n!°2) @ Jeaves and height log, n. The cost of the nodes at each depth is shown at the right,
and their sum is given in equation (4.21).

an integer, especially when visualizing the recursion tree, but the mathematics does
not require it.) Each of these children has a children, making a? nodes at depth 2,
and each of the a children has cost f(n/b?). In general, there are a/ nodes at
depth j, and each has cost f(n/b/). The cost of each leaf is T(1) = @(1), and
each leaf is at depth log, n, since n/b'°%»" = 1. There are a'°8»" = n'°8»4 leaves
in the tree.

We can obtain equation (4.21) by summing the costs of the nodes at each depth
in the tree, as shown in the figure. The cost for all internal nodes at depth j is
a f(n/b/), and so the total cost of all internal nodes is

logy, 2-1
> a! f(n/b/) .
j=0
In the underlying divide-and-conquer algorithm, this sum represents the costs of
dividing problems into subproblems and then recombining the subproblems. The
