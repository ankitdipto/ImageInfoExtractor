PARENT NODE

DEPTH

FRINGE
FRONTIER

QUEUE

Chapter 3. Solving Problems by Searching

infinite number of paths in this state space, so the search tree has an infinite number of nodes.
For example, in Figure 3.8, the branch Arad—Sibiu-Arad continues Arad—Sibiu-Arad-Sibiu—
Arad, and so on, indefinitely. Obviously, a good search algorithm avoids following such paths.
Techniques for doing this are discussed in Section 3.6.

Data structures for search trees
There are many ways to represent nodes, but in this chapter, we will assume a node is a data
structure with five components:
+ the state in the state space to which the node corresponds;
+ the node in the search tree that generated this node (this is called the parent node);
+ the operator that was applied to generate the node;
+ the number ofnodes on the path from the root to this node (the depth of the node);
+ the path cost ofthe path from the initial state to the node.
The node data type is thus:

 

datatype node
components: STATE, PARENT-NODE, OPERATOR, DEPTH, PATH-COST

 

 

 

It is important to remember the distinction between nodes and states. A node is a bookkeeping
data structure used to represent the search tree for a particular problem instance as generated by
a particular algorithm. A state represents a configuration (or set of configurations) of the world.
Thus, nodes have depths and parents, whereas states do not. (Furthermore, it is quite possible for
two different nodes to contain the same state, ifthat state is generated via two different sequences
of actions.) The EXPAND function is responsible for calculating each of the components of the
nodes it generates. ]
We also need to represent the collection of nodes that are waiting to be expanded—this

collection is called the fringe or frontier. The simplest representation would be a set of nodes.
The search strategy then would be a function that selects the next node to be expanded from
this set. Although this is conceptually straightforward, it could be computationally expensive,
because the strategy function might have to look at every element of the set to choose the best
one. Therefore, we will assume that the collection of nodes is a implemented as a queue. The
operations on a queue are as follows:

+ MAKE-QUEUE(Elementsreates a queue with the given elements.

+ Empry?(Queue) returns true only if there are no more elements in the queue.

+ REMOVE-FRONT(Queue) removes the element at the front of the queue and returns it.

* QUEUING-FN(Elements,Queuejnserts a set of elements into the queue. Different varieties

of the queuing function produce different varieties of the search algorithm.

With these definitions, we can write a more formal version of the general search algorithm. This
is shown in Figure 3.10.
