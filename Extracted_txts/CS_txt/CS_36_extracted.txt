Section 4.3.

SMa

Memory Bounded Search 107

 

 

function IDA*(problem)returns a solution sequence
inputs: problem, aproblem
static: /-limit, the current f- COST limit
mot, anode

root — MAKE-NODE(INITIAL-STATE[problem])

flimit —f- Cosi(rooty

loop do
solution, f-limit — DFS-Contour(roorf-limit)
if solution is non-null then return solution
itf-limit = oo then return failure; end

 

function DFS-ConTouR(node,flimit) returns a solution sequence and a new f- COST limit
inputs: node, a node
‘flimit, the current f- COST limit
static: next-f, the f- COST limit for the next contour, initially 2%

if f- Cost|node] > f-limit then return null, f- Cost({node]
if GoAL-TEst[problem|(STATE[node]} then return node, f- limit
for each node s in SUCCESSORS(node) do
solution, new-f —DFS-CONTOUR(S,f-limit)
if solution is non-null then return solution, {limit
next-f — MIN(next-fnew-f); end
return null, nevt-f

 

 

Figure 4.10 The IDA* (Iterative Deepening A*) search algorithm.

 

 

 

SMA* search

IDA*’s difficulties in certain problem spaces can be traced to using too little memory. Between
iterations, it retains only a single number, the current f-cost limit. Because it cannot remember
its history, IDA* is doomed to repeat it. This is doubly true in state spaces that are graphs rather
than trees (see Section 3.6). IDA* can be modified to check the current path for repeated states,
but is unable to avoid repeated states generated by alternative paths.

In this section, we describe the SMA* (Simplified Memory-Bounded A*) algorithm, which
can make use of all available memory to carry out the search. Using more memory can only
improve search efficiency—onecould always ignore the additional space, but usually it is better to
remember a node than to have to regenerate it when needed. SMA* has the following properties:

It will utilize whatever memory is made available to it.
It avoids repeated states as far as its memory allows.
It is complete ifthe available memory is sufficient to store the shallowest solution path.

It is optimal if enough memory is available to store the shallowest optimal solution path.
Otherwise, it returns the best solution that can be reached with the available memory.

When enough memory is available for the entire search tree, the search is optimally efficient.
